import sys
import os
import re
import chardet
import html
from datetime import datetime
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QLineEdit, QPushButton, QFileDialog,
    QSpinBox, QWidget, QVBoxLayout, QHBoxLayout, QGroupBox, QMessageBox
)
from PyQt5.QtCore import Qt

def detect_encoding(file_path):
    """
    파일의 인코딩을 chardet으로 자동 감지하여 반환합니다.
    """
    with open(file_path, 'rb') as f:
        raw_data = f.read()
    result = chardet.detect(raw_data)
    return result['encoding'] if result['encoding'] else 'utf-8'

def ms_to_ass_time(ms):
    """
    밀리초(ms)를 ASS 타임 포맷(h:mm:ss.xx)으로 변환합니다.
    """
    total_seconds = ms / 1000
    hours = int(total_seconds // 3600)
    minutes = int((total_seconds % 3600) // 60)
    seconds = (total_seconds % 60)
    return f"{hours}:{minutes:02d}:{seconds:05.2f}"

def convert_color_to_ass(hex_color):
    """
    #RRGGBB 형태의 색상을 ASS 오버라이드 태그용 &HBBGGRR& 형식으로 변환합니다.
    예) #33BEF1 -> &HF1BE33&
    """
    hex_color = hex_color.lstrip('#')
    if len(hex_color) != 6:
        return ""
    r = hex_color[0:2]
    g = hex_color[2:4]
    b = hex_color[4:6]
    return f"&H{b}{g}{r}&"

def parse_smi_content(smi_text):
    r"""
    SMI 텍스트를 파싱하여 아래와 같은 리스트를 반환합니다.
      [
        {
          'start': <밀리초>,
          'text': <자막 문자열 (ASS 오버라이드 태그 포함)>
        },
        ...
      ]
    - <SYNC START=...> 태그로 각 구간을 분리합니다.
    - <font> 태그를 ASS 오버라이드 태그로 변환합니다. (color=#..., size="...")
    - <br> 태그는 ASS 줄바꿈(\N)으로 변경합니다.
    - 여러 줄(일본어 + 한국어)이 있을 때, 두 번째 줄을 기본 스타일로 복원하기 위해
      두 번째 줄 시작 부분에 {\r}를 삽입합니다.
    """
    # 1) <SYNC> 블록 추출
    sync_pattern = re.compile(
        r'<SYNC START\s*=\s*(\d+)[^>]*>(.*?)((?=<SYNC)|$)',
        re.IGNORECASE | re.DOTALL
    )
    # 2) <font ...>...</font> 파싱
    font_pattern = re.compile(
        r'<font\s+([^>]+)>(.*?)</font\s*>',
        re.IGNORECASE | re.DOTALL
    )
    # 3) <br> -> \N
    br_pattern = re.compile(r'<br\s*/?>', re.IGNORECASE)
    # 4) 기타 HTML 태그 제거
    tag_pattern = re.compile(r'</?[^>]+>', re.DOTALL)

    events = []
    for match in sync_pattern.finditer(smi_text):
        start_ms = int(match.group(1))
        block_text = match.group(2)

        # (A) HTML 엔티티 (&nbsp; 등) → 실제 문자로 변환
        block_text = html.unescape(block_text)

        # (B) <br> -> \N
        block_text = br_pattern.sub(r'\\N', block_text)

        # (C) <font color=... size=...> 태그 처리
        def font_replacer(font_match):
            attr_text = font_match.group(1)  # 예: color=#33BEF1 size="30"
            inner_text = font_match.group(2) # 예: "감"
            # color 추출
            color_match = re.search(r'color\s*=\s*["\']?(#[0-9A-Fa-f]{6})["\']?', attr_text)
            # size 추출
            size_match = re.search(r'size\s*=\s*["\']?(\d+)["\']?', attr_text)

            color_tag = ""
            size_tag = ""

            if color_match:
                ass_color = convert_color_to_ass(color_match.group(1))
                if ass_color:
                    color_tag = f"{{\\1c{ass_color}}}"  # {\1c&Hxx&}

            if size_match:
                size_val = size_match.group(1)
                size_tag = f"{{\\fs{size_val}}}"       # {\fs30}

            return f"{color_tag}{size_tag}{inner_text}{{\\r}}"
        
        block_text = font_pattern.sub(font_replacer, block_text)

        # (D) 기타 HTML 태그 제거
        block_text = tag_pattern.sub('', block_text)
        block_text = block_text.strip()

        # (E) 여러 줄(\\N)이 있으면, 두 번째 줄부터 {\r}로 기본 스타일 복원
        if '\\N' in block_text:
            parts = block_text.split('\\N')
            # 첫 줄은 그대로 두고, 두 번째 줄부터 시작 부분에 {\r} 삽입
            for i in range(1, len(parts)):
                # 이미 {\r}로 끝나거나 시작하는 경우가 아니라면 추가
                if not parts[i].startswith("{\\r}"):
                    parts[i] = "{\\r}" + parts[i]
            block_text = '\\N'.join(parts)

        if not block_text:
            continue

        events.append({
            'start': start_ms,
            'text': block_text
        })
    return events

def build_ass_file(events, default_font='Arial', default_fontsize=20, last_duration=5000):
    r"""
    파싱된 events 리스트를 기반으로 ASS 파일 문자열을 생성합니다.
    last_duration은 마지막 자막의 지속 시간을 밀리초 단위로 지정합니다.
    """
    ass_header = f"""[Script Info]
; Script generated by SMI-to-ASS Converter
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1280
PlayResY: 720
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,{default_font},{default_fontsize},&H00FFFFFF,&H000000FF,&H00000000,&H64000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    ass_lines = [ass_header]

    for i in range(len(events)):
        start_ms = events[i]['start']
        text = events[i]['text']
        
        if i < len(events) - 1:
            # 다음 자막 시작 직전까지 표시 (겹침 방지를 위해 -1ms)
            end_ms = events[i+1]['start'] - 1
            if end_ms < start_ms:
                end_ms = start_ms + 1000
        else:
            # 마지막 자막은 지정된 지속시간(last_duration) 만큼 유지
            end_ms = start_ms + last_duration
        
        start_str = ms_to_ass_time(start_ms)
        end_str = ms_to_ass_time(end_ms)
        
        dialogue_line = f"Dialogue: 0,{start_str},{end_str},Default,,0,0,0,,{text}"
        ass_lines.append(dialogue_line)
    
    return "\n".join(ass_lines)

def convert_smi_to_ass(input_path, output_path, default_font='Arial', default_fontsize=20, last_duration=5):
    """
    지정된 smi 파일을 읽어 ASS 파일로 변환하여 output_path에 저장합니다.
    last_duration은 마지막 자막의 지속 시간을 초 단위로 받습니다.
    """
    try:
        encoding = detect_encoding(input_path)
        with open(input_path, 'r', encoding=encoding, errors='replace') as f:
            smi_text = f.read()
        
        events = parse_smi_content(smi_text)
        ass_str = build_ass_file(
            events,
            default_font=default_font,
            default_fontsize=default_fontsize,
            last_duration=last_duration * 1000
        )
        
        base_name = os.path.splitext(os.path.basename(input_path))[0]
        ass_filename = base_name + ".ass"
        output_file = os.path.join(output_path, ass_filename)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(ass_str)
        
        return True, f"변환 성공: {output_file}"
    except Exception as e:
        return False, str(e)

def log_error(message):
    """
    error_log.txt 파일에 [년-월-일 시:분:초.ms] 형식으로 로그를 기록합니다.
    """
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
    log_line = f"[{now}] {message}\n"
    with open("error_log.txt", "a", encoding="utf-8") as f:
        f.write(log_line)

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("SMI to ASS 변환기")
        self.resize(500, 300)

        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout()
        central_widget.setLayout(main_layout)

        # 소스 선택 그룹
        source_group = QGroupBox("소스 선택", self)
        source_layout = QVBoxLayout()
        source_group.setLayout(source_layout)
        self.edit_source = QLineEdit(self)
        source_layout.addWidget(self.edit_source)
        
        btn_layout = QHBoxLayout()
        self.btn_source_file = QPushButton("파일 선택", self)
        self.btn_source_file.clicked.connect(self.select_source_file)
        btn_layout.addWidget(self.btn_source_file)
        
        self.btn_source_dir = QPushButton("폴더 선택", self)
        self.btn_source_dir.clicked.connect(self.select_source_dir)
        btn_layout.addWidget(self.btn_source_dir)
        
        source_layout.addLayout(btn_layout)
        main_layout.addWidget(source_group)

        # 출력 경로 그룹
        output_group = QGroupBox("출력 경로", self)
        output_layout = QVBoxLayout()
        output_group.setLayout(output_layout)
        self.edit_output = QLineEdit(self)
        output_layout.addWidget(self.edit_output)
        
        btn_output_layout = QHBoxLayout()
        self.btn_output_dir = QPushButton("폴더 선택", self)
        self.btn_output_dir.clicked.connect(self.select_output_dir)
        btn_output_layout.addWidget(self.btn_output_dir)
        output_layout.addLayout(btn_output_layout)
        main_layout.addWidget(output_group)

        # 옵션 설정 그룹 (폰트, 크기, 자막 지속 시간)
        option_group = QGroupBox("옵션 설정", self)
        option_layout = QHBoxLayout()
        option_group.setLayout(option_layout)
        
        font_label = QLabel("기본 폰트:", self)
        option_layout.addWidget(font_label)
        self.edit_font = QLineEdit("Arial", self)
        option_layout.addWidget(self.edit_font)
        
        fontsize_label = QLabel("기본 크기:", self)
        option_layout.addWidget(fontsize_label)
        self.spin_fontsize = QSpinBox(self)
        self.spin_fontsize.setRange(8, 72)
        self.spin_fontsize.setValue(20)
        option_layout.addWidget(self.spin_fontsize)
        
        lastsec_label = QLabel("자막 지속 시간 (초):", self)
        option_layout.addWidget(lastsec_label)
        self.spin_lastsec = QSpinBox(self)
        self.spin_lastsec.setRange(1, 30)
        self.spin_lastsec.setValue(5)
        option_layout.addWidget(self.spin_lastsec)
        
        main_layout.addWidget(option_group)

        # 변환 시작 버튼 (가운데 정렬)
        self.btn_convert = QPushButton("변환 시작", self)
        self.btn_convert.clicked.connect(self.start_conversion)
        main_layout.addWidget(self.btn_convert, alignment=Qt.AlignCenter)

    def select_source_file(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "SMI 파일 선택", "", "SMI Files (*.smi);;All Files (*.*)")
        if file_path:
            self.edit_source.setText(file_path)
    
    def select_source_dir(self):
        dir_path = QFileDialog.getExistingDirectory(self, "폴더 선택")
        if dir_path:
            self.edit_source.setText(dir_path)
    
    def select_output_dir(self):
        dir_path = QFileDialog.getExistingDirectory(self, "출력 폴더 선택")
        if dir_path:
            self.edit_output.setText(dir_path)
    
    def start_conversion(self):
        source_path = self.edit_source.text().strip()
        output_path = self.edit_output.text().strip()
        font_name = self.edit_font.text().strip()
        font_size = self.spin_fontsize.value()
        last_sec = self.spin_lastsec.value()
        
        if not source_path:
            self.show_error("소스 경로가 설정되지 않았습니다.")
            return
        if not output_path:
            self.show_error("출력 경로가 설정되지 않았습니다.")
            return
        
        if os.path.isfile(source_path):
            success, msg = convert_smi_to_ass(
                source_path, output_path, font_name, font_size, last_sec
            )
            if success:
                QMessageBox.information(self, "변환 완료", msg)
            else:
                self.show_error(msg)
        elif os.path.isdir(source_path):
            converted_count = 0
            failed_count = 0
            for root, dirs, files in os.walk(source_path):
                for fname in files:
                    if fname.lower().endswith(".smi"):
                        fpath = os.path.join(root, fname)
                        success, msg = convert_smi_to_ass(
                            fpath, output_path, font_name, font_size, last_sec
                        )
                        if success:
                            converted_count += 1
                        else:
                            failed_count += 1
                            log_error(f"{fpath} 변환 실패: {msg}")
            QMessageBox.information(self, "변환 완료", f"총 {converted_count}개 변환 완료, 실패 {failed_count}개")
        else:
            self.show_error("유효한 파일 또는 폴더가 아닙니다.")
    
    def show_error(self, msg):
        QMessageBox.critical(self, "에러", msg)
        log_error(msg)

def log_error(message):
    """
    error_log.txt 파일에 [년-월-일 시:분:초.ms] 형식으로 로그를 기록합니다.
    """
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
    log_line = f"[{now}] {message}\n"
    with open("error_log.txt", "a", encoding="utf-8") as f:
        f.write(log_line)

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
