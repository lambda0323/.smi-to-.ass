# smi_to_ass_converter.py
# -*- coding: utf-8 -*-

import sys
import os
import re
import chardet
import html
from datetime import datetime

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QLineEdit, QPushButton, QFileDialog,
    QSpinBox, QWidget, QVBoxLayout, QHBoxLayout, QGroupBox, QMessageBox, QCheckBox, QFontComboBox
)
from PyQt5.QtCore import Qt

def detect_encoding(file_path):
    """
    파일의 인코딩을 chardet으로 자동 감지하여 반환합니다.
    """
    with open(file_path, 'rb') as f:
        raw_data = f.read()
    result = chardet.detect(raw_data)
    return result['encoding'] if result['encoding'] else 'utf-8'

def ms_to_ass_time(ms):
    """
    밀리초(ms)를 ASS 타임 포맷(h:mm:ss.xx)으로 변환합니다.
    """
    total_seconds = ms / 1000
    hours = int(total_seconds // 3600)
    minutes = int((total_seconds % 3600) // 60)
    seconds = (total_seconds % 60)
    return f"{hours}:{minutes:02d}:{seconds:05.2f}"

def convert_color_to_ass(hex_color):
    """
    #RRGGBB 형태의 색상을 ASS 오버라이드 태그용 &HBBGGRR& 형식으로 변환합니다.
    예) #33BEF1 -> &HF1BE33&
    """
    hex_color = hex_color.lstrip('#')
    if len(hex_color) != 6:
        return ""
    r = hex_color[0:2]
    g = hex_color[2:4]
    b = hex_color[4:6]
    return f"&H{b}{g}{r}&"

def parse_smi_content(smi_text, override_fontsize=None):
    r"""
    SMI 텍스트를 파싱하여 아래와 같은 리스트를 반환합니다.
      [
        {
          'start': <밀리초>,
          'text': <자막 문자열 (ASS 오버라이드 태그 포함)>
        },
        ...
      ]

    - <SYNC START=...> 태그로 각 구간을 분리합니다.
    - <font> 태그를 ASS 오버라이드 태그로 변환합니다. (color=#..., size="...")
      * override_fontsize 값이 있으면 SMI에 명시된 size 대신 해당 값을 사용합니다.
    - <br> 태그는 ASS 줄바꿈(\N)으로 변경합니다.
    - 여러 줄(일본어 + 한국어)이 있을 때, 두 번째 줄을 기본 스타일로 복원하기 위해
      두 번째 줄 시작 부분에 {\r}를 삽입합니다. 
      또한, 각 줄별로 font 태그를 개별 적용합니다.
    """
    # 1) <SYNC START=...> 블록 추출
    sync_pattern = re.compile(
        r'<SYNC START\s*=\s*(\d+)[^>]*>(.*?)((?=<SYNC)|$)',
        re.IGNORECASE | re.DOTALL
    )
    # 2) <font ...>...</font> 파싱
    font_pattern = re.compile(
        r'<font\s+([^>]+)>(.*?)</font\s*>',
        re.IGNORECASE | re.DOTALL
    )
    # 3) <br> -> \N
    br_pattern = re.compile(r'<br\s*/?>', re.IGNORECASE)
    # 4) 기타 HTML 태그 제거용
    tag_pattern = re.compile(r'</?[^>]+>', re.DOTALL)

    events = []
    for match in sync_pattern.finditer(smi_text):
        start_ms = int(match.group(1))
        block_text = match.group(2)

        # (A) HTML 엔티티(&nbsp; 등) → 실제 문자로 변환
        block_text = html.unescape(block_text)

        # (B) <br> -> \N
        block_text = br_pattern.sub(r'\\N', block_text)

        # (C) <font ...> 태그 처리
        def font_replacer(font_match):
            attr_text = font_match.group(1)  # 예: color=#33BEF1 size="30"
            inner_text = font_match.group(2)  # 예: "감"

            color_match = re.search(r'color\s*=\s*["\']?(#[0-9A-Fa-f]{6})["\']?', attr_text)
            size_match = re.search(r'size\s*=\s*["\']?(\d+)["\']?', attr_text)

            color_tag = ""
            size_tag = ""

            if color_match:
                ass_color = convert_color_to_ass(color_match.group(1))
                if ass_color:
                    color_tag = f"{{\\1c{ass_color}}}"  # {\1c&Hxx&}

            if size_match:
                if override_fontsize is not None:
                    size_tag = f"{{\\fs{override_fontsize}}}"
                else:
                    size_val = size_match.group(1)
                    size_tag = f"{{\\fs{size_val}}}"

            # 글자 뒤에 {\r}로 스타일 리셋
            return f"{color_tag}{size_tag}{inner_text}{{\\r}}"

        # 줄 단위(\N)로 나눈 뒤 각각 처리
        lines = block_text.split('\\N')
        processed_lines = []
        for i, line in enumerate(lines):
            # font 태그 처리
            line = font_pattern.sub(font_replacer, line)
            # 기타 HTML 태그 제거
            line = tag_pattern.sub('', line).strip()
            # 두 번째 줄부터는 {\r}로 기본 스타일 복원
            if i > 0 and not line.startswith("{\\r}"):
                line = "{\\r}" + line
            processed_lines.append(line)

        block_text = '\\N'.join(processed_lines)

        if not block_text.strip():
            continue

        events.append({
            'start': start_ms,
            'text': block_text
        })
    return events

def build_ass_file(events, default_font='Arial', default_fontsize=20, last_duration=5000):
    r"""
    파싱된 events 리스트를 기반으로 ASS 파일 문자열을 생성합니다.
    last_duration은 마지막 자막의 지속 시간을 밀리초 단위로 지정합니다.

    - events: [
        { 'start': 1000, 'text': '자막내용1' },
        { 'start': 3000, 'text': '자막내용2' },
        ...
      ]
    """
    ass_header = f"""[Script Info]
; Script generated by SMI-to-ASS Converter
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1280
PlayResY: 720
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,{default_font},{default_fontsize},&H00FFFFFF,&H000000FF,&H00000000,&H64000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    ass_lines = [ass_header]

    for i in range(len(events)):
        start_ms = events[i]['start']
        text = events[i]['text']

        # 다음 이벤트 시작 직전까지 유지, 없으면 last_duration
        if i < len(events) - 1:
            end_ms = events[i+1]['start'] - 1
            if end_ms < start_ms:
                end_ms = start_ms + 1000
        else:
            end_ms = start_ms + last_duration

        start_str = ms_to_ass_time(start_ms)
        end_str = ms_to_ass_time(end_ms)

        dialogue_line = f"Dialogue: 0,{start_str},{end_str},Default,,0,0,0,,{text}"
        ass_lines.append(dialogue_line)

    return "\n".join(ass_lines)

def convert_smi_to_ass(input_path, output_path, default_font='Arial', default_fontsize=20, last_duration=5, override_fontsize=None):
    """
    지정된 smi 파일을 읽어 ASS 파일로 변환하여 output_path에 저장합니다.
    last_duration은 마지막 자막의 지속 시간을 '초' 단위로 받습니다.
    override_fontsize가 지정되면 SMI 파일 내의 폰트 사이즈 대신 해당 값을 적용합니다.
    """
    try:
        encoding = detect_encoding(input_path)
        with open(input_path, 'r', encoding=encoding, errors='replace') as f:
            smi_text = f.read()

        # SMI 파싱 (override_fontsize 인자 전달)
        events = parse_smi_content(smi_text, override_fontsize=override_fontsize)

        # ASS 문자열 생성
        ass_str = build_ass_file(
            events,
            default_font=default_font,
            default_fontsize=default_fontsize,
            last_duration=last_duration * 1000
        )

        base_name = os.path.splitext(os.path.basename(input_path))[0]
        ass_filename = base_name + ".ass"
        output_file = os.path.join(output_path, ass_filename)

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(ass_str)

        return True, f"변환 성공: {output_file}"
    except Exception as e:
        return False, str(e)

def log_error(message):
    """
    error_log.txt 파일에 [년-월-일 시:분:초.ms] 형식으로 로그를 기록합니다.
    """
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
    log_line = f"[{now}] {message}\n"
    with open("error_log.txt", "a", encoding="utf-8") as f:
        f.write(log_line)

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("SMI to ASS 변환기")
        self.resize(600, 400)  # 창 크기 조정

        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout()
        central_widget.setLayout(main_layout)

        # (1) 소스 선택 그룹
        source_group = QGroupBox("소스 선택", self)
        source_layout = QHBoxLayout()
        source_group.setLayout(source_layout)

        self.edit_source = QLineEdit(self)
        source_layout.addWidget(self.edit_source)

        self.btn_source_file = QPushButton("파일 선택", self)
        self.btn_source_file.clicked.connect(self.select_source_file)
        source_layout.addWidget(self.btn_source_file)

        self.btn_source_dir = QPushButton("폴더 선택", self)
        self.btn_source_dir.clicked.connect(self.select_source_dir)
        source_layout.addWidget(self.btn_source_dir)

        main_layout.addWidget(source_group)

        # (2) 출력 경로 그룹
        output_group = QGroupBox("출력 경로", self)
        output_layout = QHBoxLayout()
        output_group.setLayout(output_layout)

        self.edit_output = QLineEdit(self)
        output_layout.addWidget(self.edit_output)

        self.btn_output_dir = QPushButton("폴더 선택", self)
        self.btn_output_dir.clicked.connect(self.select_output_dir)
        output_layout.addWidget(self.btn_output_dir)

        main_layout.addWidget(output_group)

        # (3) 옵션 설정 그룹 (폰트, 크기, 자막 지속 시간, 폰트 사이즈 오버라이드)
        option_group = QGroupBox("옵션 설정", self)
        option_layout = QVBoxLayout()
        option_group.setLayout(option_layout)

        # 폰트 선택 (QFontComboBox)
        font_layout = QHBoxLayout()
        font_label = QLabel("기본 폰트:", self)
        font_layout.addWidget(font_label)
        self.font_combo_box = QFontComboBox(self)
        # 기본값을 Arial로 설정
        self.font_combo_box.setCurrentFont(self.font_combo_box.font())
        font_layout.addWidget(self.font_combo_box)
        option_layout.addLayout(font_layout)

        # 기본 폰트 크기 (스타일 헤더용 및 오버라이드용)
        fontsize_layout = QHBoxLayout()
        fontsize_label = QLabel("기본 크기:", self)
        fontsize_layout.addWidget(fontsize_label)
        self.spin_fontsize = QSpinBox(self)
        self.spin_fontsize.setRange(8, 72)
        self.spin_fontsize.setValue(20)
        fontsize_layout.addWidget(self.spin_fontsize)
        option_layout.addLayout(fontsize_layout)

        # SMI 폰트 사이즈 무시 옵션 (체크하면 SMI에 명시된 폰트 크기 대신 위의 기본 크기를 사용)
        self.checkbox_override_fontsize = QCheckBox("SMI 폰트 사이즈 무시 (기본 크기 적용)", self)
        option_layout.addWidget(self.checkbox_override_fontsize)

        # 자막 지속 시간
        lastsec_layout = QHBoxLayout()
        lastsec_label = QLabel("자막 지속 시간 (초):", self)
        lastsec_layout.addWidget(lastsec_label)
        self.spin_lastsec = QSpinBox(self)
        self.spin_lastsec.setRange(1, 30)
        self.spin_lastsec.setValue(5)
        lastsec_layout.addWidget(self.spin_lastsec)
        option_layout.addLayout(lastsec_layout)

        main_layout.addWidget(option_group)

        # (4) 변환 시작 버튼
        self.btn_convert = QPushButton("변환 시작", self)
        self.btn_convert.clicked.connect(self.start_conversion)
        main_layout.addWidget(self.btn_convert, alignment=Qt.AlignCenter)

    def select_source_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "SMI 파일 선택", "",
            "SMI Files (*.smi);;All Files (*.*)"
        )
        if file_path:
            self.edit_source.setText(file_path)

    def select_source_dir(self):
        dir_path = QFileDialog.getExistingDirectory(self, "폴더 선택")
        if dir_path:
            self.edit_source.setText(dir_path)

    def select_output_dir(self):
        dir_path = QFileDialog.getExistingDirectory(self, "출력 폴더 선택")
        if dir_path:
            self.edit_output.setText(dir_path)

    def start_conversion(self):
        source_path = self.edit_source.text().strip()
        output_path = self.edit_output.text().strip()
        # QFontComboBox에서 선택한 폰트
        font_name = self.font_combo_box.currentFont().family()
        font_size = self.spin_fontsize.value()
        last_sec = self.spin_lastsec.value()

        # override_fontsize: 체크되면 SMI 폰트 사이즈 무시하고 기본 폰트 크기를 사용
        override_fontsize = font_size if self.checkbox_override_fontsize.isChecked() else None

        if not source_path:
            self.show_error("소스 경로가 설정되지 않았습니다.")
            return
        if not output_path:
            self.show_error("출력 경로가 설정되지 않았습니다.")
            return

        # (A) 소스가 파일인지 폴더인지 판별
        if os.path.isfile(source_path):
            success, msg = convert_smi_to_ass(
                source_path, output_path,
                default_font=font_name,
                default_fontsize=font_size,
                last_duration=last_sec,
                override_fontsize=override_fontsize
            )
            if success:
                QMessageBox.information(self, "변환 완료", msg)
            else:
                self.show_error(msg)

        elif os.path.isdir(source_path):
            converted_count = 0
            failed_count = 0
            for root, dirs, files in os.walk(source_path):
                for fname in files:
                    if fname.lower().endswith(".smi"):
                        fpath = os.path.join(root, fname)
                        success, msg = convert_smi_to_ass(
                            fpath, output_path,
                            default_font=font_name,
                            default_fontsize=font_size,
                            last_duration=last_sec,
                            override_fontsize=override_fontsize
                        )
                        if success:
                            converted_count += 1
                        else:
                            failed_count += 1
                            log_error(f"{fpath} 변환 실패: {msg}")

            QMessageBox.information(
                self, "변환 완료",
                f"총 {converted_count}개 변환 완료, 실패 {failed_count}개"
            )
        else:
            self.show_error("유효한 파일 또는 폴더가 아닙니다.")

    def show_error(self, msg):
        QMessageBox.critical(self, "에러", msg)
        log_error(msg)

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
